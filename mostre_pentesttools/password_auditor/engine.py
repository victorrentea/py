"""Module that holds the Engine class implementation."""
import logging
import time
from enum import Enum
from queue import Queue
from threading import Lock, Thread
from typing import Iterator

from tools.core.http_authenticator import HttpAuthenticator
from tools.core.selenium_chrome_docker import BrowserConnection, NoBrowserConnectionException, init_custom_driver
from tools.password_auditor.auth_tasks.auth_task import AuthTask
from tools.password_auditor.auth_tasks.web_form_task import WebFormTask
from tools.password_auditor.constants import AttackType
from tools.password_auditor.exceptions import (
    AccountLockoutDetected,
    CaptchaWebFormDetected,
    FalsePositiveDetected,
    SeleniumSessionIdException,
    WebsiteAccessBlocked,
)

MAX_QUEUE_SIZE = 1000
MAX_CREDENTIALS_FOUND = 2
MUTEX = Lock()


class EngineStopReasons(Enum):
    """Enum containing reasons the engine can stop before finishing all tasks"""

    MAX_CREDENTIALS_FOUND = "MAX_CREDENTIALS_FOUND reached"
    LOCKOUT = "Account lockout detected"
    SCAN_STOPPED = "Password Auditor scan was manually stopped"
    ACCESS_BLOCKED = "Website access was blocked"
    CAPTCHA_DETECTED = "CAPTCHA detected in page"
    SELENIUM_DRIVER_EXITED = "WebDriver stopped during HTTP brute-force"
    FALSE_POSITIVE_DETECTED = "A high probability of False Positives was detected"


class Engine:
    """Class responsible for spawning threads, each running a task, and gathering the successful ones at the end."""

    def __init__(
        self,
        scan_activity,
        attempts_delay: int,
        attack_type: AttackType,
        num_threads: int,
        http_authenticator: HttpAuthenticator = None,
    ):
        self.do_run = False
        self.started = False
        self.attempts_delay = attempts_delay
        self.num_processed_tasks = 0
        self.successful_tasks = []
        self.successful_task_usernames = []
        self.scan_activity = scan_activity
        self.stop_reason = None
        self.lockout_username = None
        self.queue = None
        self.attack_type = attack_type
        self.num_threads = num_threads
        self.http_authenticator = http_authenticator

    def run(
        self,
        task_generator: Iterator[AuthTask],
        username_count: int = None,
        lockout_period: int = None,
        attempts_per_period: int = None,
    ) -> list[AuthTask]:
        """Starts and ends the threads, the task queue, and returns the successful tasks."""

        if self.do_run:
            raise Exception("Cannot start engine. This engine is already running.")

        self.do_run = True
        self.started = True

        self.queue = Queue()

        self.start_threads()

        if self.attack_type == AttackType.PASSWORD_SPRAY:
            logging.info("Starting tasks - Password Spray attack")
            self.run_password_spray_attack(task_generator, username_count, lockout_period, attempts_per_period)
        else:
            logging.info("Starting tasks - Default attack")
            self.run_default_attack(task_generator)

        self.do_run = False
        logging.info("Num proccessed tasks: %i", self.num_processed_tasks)

        if self.stop_reason == EngineStopReasons.LOCKOUT:
            raise AccountLockoutDetected(self.lockout_username)

        if self.stop_reason == EngineStopReasons.ACCESS_BLOCKED:
            raise WebsiteAccessBlocked(self.num_processed_tasks)

        return self.successful_tasks

    def start_threads(self):
        """Initializes and starts the threads that will be executing auth_tasks"""

        logging.info("Starting %s threads", self.num_threads)
        for thread_id in range(self.num_threads):
            if self.http_authenticator:
                driver_id = thread_id + 1
                # Some drivers may already be created (from check_service_connectivity or other ports)
                try:
                    self.http_authenticator.selenium_container.get_started_browser_connection(driver_id)
                    logging.debug("Already present webdriver with id %s", driver_id)
                except NoBrowserConnectionException:
                    logging.debug("Creating new webdriver with id %s", driver_id)
                    driver = init_custom_driver(self.http_authenticator.selenium_container.port)
                    browser_connection = BrowserConnection(driver, None, driver_id)
                    self.http_authenticator.selenium_container.set_already_created_connection(browser_connection)

                thread = Thread(target=self.thread_run, args=(driver_id,))
            else:
                thread = Thread(target=self.thread_run)
            thread.daemon = True
            thread.start()

    def run_default_attack(self, task_generator):
        """Runs the tasks in order from the task_generator."""

        for task in task_generator:
            # Stop the attack if self.do_run was set to False because a thread called stop_queue
            if not self.do_run:
                logging.info("Stopping - queue was stopped")
                return

            # Check if max successful tasks were found already
            if len(self.successful_tasks) >= MAX_CREDENTIALS_FOUND:
                self.stop_queue(EngineStopReasons.MAX_CREDENTIALS_FOUND)
                return

            # We don't set MAX_QUEUE_SIZE at the beginning because
            # the threads can also put tasks in the queue
            # and block each other while waiting for it to empty
            while self.queue.qsize() >= MAX_QUEUE_SIZE and self.do_run:
                time.sleep(1)
            self.queue.put(task)

        self.queue.join()

    def run_password_spray_attack(self, task_generator, username_count, lockout_period, attempts_per_period):
        """
        Runs a password spraying attack: Tries {attempts_per_period} passwords for every username in the wordlist,
        then waits {lockout_period} seconds in order to avoid user account lockout.
        """

        while True:
            for _ in range(attempts_per_period):
                for _ in range(username_count):
                    # Stop the attack if self.do_run was set to False because a thread called stop_queue
                    if not self.do_run:
                        logging.info("Stopping - queue was stopped")
                        return

                    task = next(task_generator, None)
                    if not task:
                        self.queue.join()
                        return

                    # Check if max successful tasks were found already
                    if len(self.successful_tasks) >= MAX_CREDENTIALS_FOUND:
                        self.stop_queue(EngineStopReasons.MAX_CREDENTIALS_FOUND)
                        return

                    # We don't set MAX_QUEUE_SIZE at the beginning because
                    # the threads can also put tasks in the queue
                    # and block each other while waiting for it to empty
                    while self.queue.qsize() >= MAX_QUEUE_SIZE and self.do_run:
                        time.sleep(1)
                    self.queue.put(task)

                self.queue.join()

            msg = f"Waiting for lockout period to pass ({lockout_period} seconds)..."
            self.scan_activity.append(msg)
            logging.info(msg)
            time.sleep(lockout_period)

    def stop_queue(self, reason: EngineStopReasons = EngineStopReasons.SCAN_STOPPED):
        """Forces the queue to stop by setting the do_run flag and putting MAX_QUEUE_SIZE task_done."""

        self.do_run = False
        self.stop_reason = reason
        logging.warning("Stopping queue: %s", reason.value)
        self.mark_task_done(no_times=MAX_QUEUE_SIZE)

    def check_fp_scenario(self, auth_task: WebFormTask) -> None:
        """Used when a web_form_task is considered to have successful authentication. Starts a new task with an altered password
        and raises FalsePositiveDetected if successful authentication is detected with an altered password as well."""

        fp_task = WebFormTask(
            auth_task.id,
            auth_task.host,
            auth_task.port,
            auth_task.username,
            f"{auth_task.password}a",
            auth_task.scan_task_id,
            auth_task.service_name,
        )

        fp_task.http_authenticator = auth_task.http_authenticator
        fp_task.driver_id = auth_task.driver_id

        while fp_task.num_retries < 3:
            fp_task.connect()

            if fp_task.conn_status == AuthTask.SUCCESS:
                break

            fp_task.num_retries += 1

        if fp_task.conn_status == AuthTask.FAILED:
            # TODO: Change exception when a mechanism for detecting unresponsive servers is implemented.
            raise FalsePositiveDetected("Server seems to be unresponsive.")

        if fp_task.auth_status == AuthTask.SUCCESS:
            raise FalsePositiveDetected("Authentication succeeded with different passwords for same user.")

    def thread_run(self, driver_id: int = -1):
        """Thread function: runs a task at a time from the queue and checks its status.
        If successful, it adds it to the successful_tasks list. Else, retry for num_retries times."""

        while self.do_run:
            try:
                auth_task = self.queue.get()

                # If a password was already found for a certain username, skip all further tasks for that username
                if auth_task.username in self.successful_task_usernames:
                    self.inc_num_processed_tasks()
                    continue

                self.scan_activity.append(f"Trying {auth_task.username}:{auth_task.password}")
                # Only for web_form_task with Selenium
                if self.http_authenticator and driver_id != -1:
                    auth_task.http_authenticator = self.http_authenticator
                    auth_task.driver_id = driver_id
                auth_task.connect()

                if auth_task.conn_status == AuthTask.SUCCESS:
                    self.inc_num_processed_tasks()
                    if auth_task.auth_status == AuthTask.SUCCESS:
                        if self.http_authenticator:
                            self.check_fp_scenario(auth_task)

                        if not self.add_successful_task(auth_task):
                            self.stop_queue(EngineStopReasons.MAX_CREDENTIALS_FOUND)
                else:
                    if auth_task.num_retries < 3:
                        auth_task.num_retries += 1
                        self.queue.put(auth_task)
                    else:
                        self.inc_num_processed_tasks()

                # Add auth_task.num_retries so that the delay is increased as the attempts keep failing
                time.sleep(self.attempts_delay + auth_task.num_retries)

            except AccountLockoutDetected as exception:
                self.inc_num_processed_tasks()
                self.lockout_username = exception.username
                self.stop_queue(EngineStopReasons.LOCKOUT)

            except SeleniumSessionIdException:
                # Check if the exception occurred unexpectedly or not
                if not self.do_run:
                    logging.warning("Selenium SessionId exception was raised after manually stopping scan")
                else:
                    self.stop_queue(reason=EngineStopReasons.SELENIUM_DRIVER_EXITED)
                    logging.exception("Selenium SessionId exception in connecting to the server")

            except CaptchaWebFormDetected:
                self.inc_num_processed_tasks()
                self.stop_queue(EngineStopReasons.CAPTCHA_DETECTED)

            except WebsiteAccessBlocked:
                self.inc_num_processed_tasks()
                self.stop_queue(EngineStopReasons.ACCESS_BLOCKED)

            except FalsePositiveDetected:
                self.inc_num_processed_tasks()
                self.stop_queue(EngineStopReasons.FALSE_POSITIVE_DETECTED)

            except:
                logging.exception("Unknown task exception in engine thread_run")

            finally:
                self.mark_task_done()

    def inc_num_processed_tasks(self):
        """Increments the self.num_processed_tasks attribute in an atomic way"""
        with MUTEX:
            self.num_processed_tasks += 1

    def add_successful_task(self, task: AuthTask) -> bool:
        """Adds a task to the successful_tasks list in an atomic way.
        Returns True if the task was added, False if not (MAX_CREDENTIALS_FOUND was reached)."""

        with MUTEX:
            if (
                len(self.successful_tasks) < MAX_CREDENTIALS_FOUND
                and task.username not in self.successful_task_usernames
            ):
                self.successful_tasks.append(task)
                # Keep usernames that passwords were found for
                # so that further tasks with the same username can be skipped
                self.successful_task_usernames.append(task.username)
            if len(self.successful_tasks) >= MAX_CREDENTIALS_FOUND:
                return False

            return True

    def mark_task_done(self, no_times: int = 1):
        """Puts a task_done in the queue for no_times number of times"""

        try:
            for _ in range(no_times):
                self.queue.task_done()
        except ValueError:
            pass
