"""
This is the main module of the Password Auditor tool.

For Victor:
This tool (Password Auditor) uses an initial usernames wordlist and a password wordlist
and performs brute force login on different services: HTTP web form (most common), SSH,
MySQL etc.

First, it scans for open ports on the target and checks what services to scan.
Then, it iterates through each open port and, before attempting the brute force, it does a series of
initial checks - for instance, it checks the connectivity of the service (we can attempt a login on 
the service).
Finally it starts the "engine" (see the other file) which
takes care of spawning the threads (the brute force is parallelized).
Each thread takes a "task" (AuthTask) at a time from the queue and performs it.
A task is nothing more than a login attempt with one username and one password from the lists.
Finally the task returns with the status FAILED or SUCCESS (if the auth failed or succeeded).
"""
import argparse
import csv
import logging
import sys
import time
from threading import Thread
from urllib.parse import urlparse

import tldextract

from tools.core.scanner_base import VulnerabilityScanner
from tools.core.selenium_chrome_docker import ConnectionToSeleniumError
from tools.core.task_base import TaskStatus, VulnerabilityTest, set_logger
from tools.core.utils_data_formats import construct_html_link
from tools.core.utils_network import (
    NmapNoResolvableHostsException,
    NmapTimeoutException,
    scan_ports_multihost,
)
from tools.password_auditor import pa_utils
from tools.password_auditor.auth_tasks.auth_task import AuthTask
from tools.password_auditor.auth_tasks.rdp_task import RdpTask
from tools.password_auditor.constants import (
    CUSTOM_NUM_THREADS,
    DEFAULT_ATTEMPTS_PER_PERIOD,
    DEFAULT_CREDENTIALS_PATH,
    DEFAULT_LOCKOUT_PERIOD,
    DEFAULT_NUM_THREADS,
    DEFAULT_PASSWORDS_FILE,
    DEFAULT_USERNAMES_FILE,
    PORTS_LISTS_PATH,
    SERVICES_NAMES,
    SERVICES_NO_AUTH,
    SUPPORTED_SERVICES,
    VULN_REFERENCE,
    AttackType,
)
from tools.password_auditor.engine import (
    MAX_CREDENTIALS_FOUND,
    Engine,
    EngineStopReasons,
)
from tools.password_auditor.exceptions import (
    AccountLockoutDetected,
    WebFormTaskException,
    WebsiteAccessBlocked,
)
from tools.password_auditor.web_form_utils import init_http_authenticator


class PasswordAuditor(VulnerabilityScanner):
    """Implements the PasswordAuditor tool as a VulnerabilityScanner."""

    def __init__(
        self,
        target,
        service_types,
        usernames_file,
        passwords_file,
        custom_login_url,
        custom_ports,
        attempts_delay,
        check_default_creds,
        attack_type,
        lockout_period,
        attempts_per_period,
    ):
        VulnerabilityScanner.__init__(self)

        self.tool_name = "Password Auditor"
        self.target = target
        self.attack_type = attack_type
        self.custom_login_url = custom_login_url
        self.attempts_delay = attempts_delay
        self.check_default_creds = check_default_creds
        self.lockout_period = lockout_period * 60 if attack_type == AttackType.PASSWORD_SPRAY else 0
        self.attempts_per_period = attempts_per_period
        self.results = None
        if custom_ports is None:
            self.ports = pa_utils.load_port_list(PORTS_LISTS_PATH + "tcp-100.txt")
        else:
            self.ports = custom_ports

        if usernames_file == "default":
            self.usernames_file = DEFAULT_USERNAMES_FILE
        else:
            self.usernames_file = usernames_file
        if passwords_file == "default":
            self.passwords_file = DEFAULT_PASSWORDS_FILE
        else:
            self.passwords_file = passwords_file

        self.services = [
            SUPPORTED_SERVICES[service_type]
            for service_type in service_types.split(",")
            if service_type in SUPPORTED_SERVICES
        ]

        if "http" in self.services and "https" not in self.services:
            self.services.append("https")

        self.progress = 0
        self.engine = None
        self.http_authenticator = None
        self.selenium_container = None

    def run(self):
        """This method calls each function that implements a test, in the desired order"""
        try:
            self.progress = 1

            # Discover open ports on the target host
            open_ports = self.testfunc___scan_host_for_ports()

            # Check for weak passwords
            if open_ports:
                self.check_for_weak_passwords(open_ports)

            self.progress = 100

        except:
            logging.exception("Unknown exception in run() method")
            self.abort()

        finally:
            # Wait for the latest output to be sent to Redis, then exit
            logging.debug("Waiting...")
            self.wait_to_finish()
            logging.debug("Finished")

    def testfunc___scan_host_for_ports(self):
        """
        Scan the host with Nmap to discover open ports and return the ones with services supported by Password Auditor.
        Returns: list of OpenPort objects.
        """

        scan_test = self.start_test("Scanning target for open ports...")
        logging.info("Scanning target for open ports with nmap...")
        nmap_results, open_ports = [], []

        try:
            nmap_results, _ = scan_ports_multihost({self.target}, self.ports, service_version=True, scan_type="-sT")

        except NmapNoResolvableHostsException:
            scan_test.set_vuln_notfound(
                "Target hostname could not be resolved. Please try scanning the IP address of the target"
            )
            self.finish_test(scan_test)
            return open_ports

        except NmapTimeoutException:
            logging.warning("NmapTimeoutException")

        open_ports = self.parse_nmap_results(nmap_results)
        logging.info("Open ports with the selected services: %s", open_ports)

        self.progress = 30

        if not open_ports:
            scan_test.set_vuln_notfound("Found 0 open ports with the selected services")
        else:
            vuln_description = f"Found {len(open_ports)} open port{'s' if len(open_ports) > 1 else ''}"
            risk_level = scan_test.RISK_INFO
            risk_description = (
                "This is the list of ports that have been found open on the target host.<br>"
                "Having unnecessary open ports may expose the target system to risks "
                "because those network services and applications may contain vulnerabilities."
            )
            recommendation = (
                "We recommend reviewing the list of open ports and closing"
                " the ones which are not necessary for business purposes."
            )
            scan_test.vuln_id = "PASSAUD-00-" + "1".zfill(7)
            evidence = [
                [
                    "<b>Server</b>",
                    "<b>Open Port</b>",
                    "<b>Service</b>",
                    "<b>URL</b>",
                ]
            ]
            for open_port in open_ports:
                evidence.append(
                    [
                        open_port.server,
                        open_port.port,
                        open_port.service,
                        construct_html_link(open_port.extra["url"]) if open_port.extra.get("url") else "-",
                    ]
                )

            scan_test.set_vuln_found(vuln_description, risk_level, evidence, risk_description, recommendation)

        self.finish_test(scan_test)

        return open_ports

    def do_prior_checks(self, open_port) -> bool:
        """
        Runs some checks before attempting the brute forcing:
        service connectivity, no auth, default/common credentials.
        Return: bool
            whether the brute forcing part should continue after this.
        """

        # This means the service is credentialless, so there is no need for brute force
        if open_port.service in SERVICES_NO_AUTH and self.check_no_auth(open_port):
            return False

        try:
            # Check the service connection and whether it supports authentication
            conn_result = pa_utils.check_service_connectivity(open_port, self.http_authenticator, self.task_id)
        except (WebFormTaskException, WebsiteAccessBlocked) as exception:
            self.add_connectivity_failed_info_finding(open_port, str(exception))
            return False

        # Check for out of scope redirection
        if (
            open_port.extra.get("auth_type") == "web-form"
            and tldextract.extract(open_port.server).domain != tldextract.extract(open_port.extra["url"]).domain
        ):
            msg = (
                f"Target redirects to a URL which is out of scope for the {SERVICES_NAMES[open_port.service]} service. "
            )
            msg += "Please scan the login URL directly"
            self.add_connectivity_failed_info_finding(open_port, msg)
            return False

        if not conn_result:
            msg = f"Could not attempt authentication on {SERVICES_NAMES[open_port.service]} service"
            self.add_connectivity_failed_info_finding(open_port, msg)
            return False

        if self.check_default_creds:
            return self.check_default_credentials(open_port)

        return True

    def add_connectivity_failed_info_finding(self, open_port: pa_utils.OpenPort, msg: str):
        """Creates the connectivity test and adds an info finding that specifies why it failed

        Parameters:
            open_port -- the OpenPort where connectivity failed, used for test description and logging
            msg       -- the message to use as a title for the informational finding
        """
        scan_test = self.start_test(f"Checking service connectivity on port {open_port.port}...")
        logging.warning("%s port=%d", msg, open_port.port)
        scan_test.set_vuln_notfound(msg, port=open_port.port, service=SERVICES_NAMES[open_port.service])
        self.finish_test(scan_test)

    def check_no_auth(self, open_port: pa_utils.OpenPort):
        """Custom made function for credentialless auth check. If the auth needs no credentials, there is no need
        to have multiple auth attempts so we make only one attempt, from this function."""

        no_auth_task = pa_utils.create_task(1, open_port, "", "", self.task_id)
        no_auth_task.connect()
        open_port.extra["task"] = no_auth_task

        # Because credentialless tasks have various types of evidence and not a user+password combo
        if no_auth_task.auth_status == AuthTask.SUCCESS:
            # For a port where no authentication was configured, construct the evidence, risk details,
            # recommendation etc. and adds them to the scan test.
            scan_test = self.start_test(
                f"Checking for no authentication configured on port {open_port.port}...",
            )
            vuln_title = f"No authentication configured on {SERVICES_NAMES[open_port.service]}"
            vuln_description = (
                "The service is vulnerable to attacks because no method of securing the "
                "authentication is configured."
            )
            risk_level = scan_test.RISK_HIGH
            risk_description = (
                "The risk exists that a remote unauthenticated attacker can login through "
                "the service and compromise the server in order to steal sensitive information, "
                "install ransomware or pivot to the internal network."
            )
            recommendation = (
                "We recommend configuring a secure way of authentication. "
                "If this is not possible, stop exposing the port."
            )
            scan_test.vuln_id = "PA-" + open_port.service

            task_evidence = no_auth_task.get_evidence()
            if task_evidence:
                evidence = [
                    [
                        "<b>Server</b>",
                        "<b>Open Port</b>",
                        "<b>Service</b>",
                        "<b>Running Images Short ID</b>",
                    ]
                ]
                row = [
                    open_port.server,
                    open_port.port,
                    open_port.service,
                    f"{task_evidence}, ...",
                ]
            else:
                evidence = [["<b>Server</b>", "<b>Open Port</b>", "<b>Service</b>"]]
                row = [open_port.server, open_port.port, open_port.service]
            evidence.append(row)

            scan_test.set_vuln_found(
                vuln_description,
                risk_level,
                evidence,
                risk_description,
                recommendation,
                vuln_title=vuln_title,
                references=VULN_REFERENCE,
                port=open_port.port,
                service=SERVICES_NAMES[open_port.service],
            )
            self.finish_test(scan_test)

            return True

        return False

    def check_for_weak_passwords(self, open_ports: list[pa_utils.OpenPort]):
        """
        For each open port found, uses the Engine to perform a list of AuthTasks and adds the results to the UI.
        The Engine receives a task_generator, runs the tasks in a queue and returns a list of those where the
        authentication succeeded.
        A task is an attempt to authenticate using a pair of (username, password) from the initial wordlists.
        """

        if not open_ports:
            return

        progress_increment = int((100 - self.progress) / len(open_ports))
        usernames, passwords = self.load_wordlists()

        # If any of the tasks will involve web form auth, init the global HttpAuthenticator here
        if any(open_port.extra.get("auth_type") == "web-form" for open_port in open_ports):
            self.initialize_selenium(parallel_drivers_count=DEFAULT_NUM_THREADS)
            self.selenium_container = self.get_chrome_docker()
            try:
                self.http_authenticator = init_http_authenticator(selenium_container=self.selenium_container)
            except ConnectionToSeleniumError:
                # This is raised when connection to the webdriver fails
                # We set http_authenticator to None which will cause the connectivity check
                # to fail for web-form services, while other services remain unaffected
                logging.exception("Failed to connect to Selenium container")
                self.http_authenticator = None
        for open_port in open_ports:
            # Perform some initial checks to determine if we should start bruteforcing
            if not self.do_prior_checks(open_port):
                self.progress += progress_increment
                continue

            scan_test = self.start_test(
                f"Searching for weak credentials on port {open_port.port}...",
            )

            # Start brute force attack using the Engine
            lockout_username = None
            tasks_before_access_blocked = None
            successful_tasks = []

            try:
                # Avoid starting another engine when the WebDriver hasn't exited yet in self.stop()
                if not self.do_run:
                    scan_test.set_vuln_notfound(
                        f"No {SERVICES_NAMES[open_port.service]} Weak Password Found",
                        port=open_port.port,
                        service=SERVICES_NAMES[open_port.service],
                    )
                    self.finish_test(scan_test)
                    break
                successful_tasks = self.run_engine(open_port, usernames, passwords, self.attack_type)
            except AccountLockoutDetected as exception:
                lockout_username = exception.username
            except WebsiteAccessBlocked as exception:
                # This can only happen in WebForm tasks due to a WAF
                # We count 1 more task that corresponds to the one in check_service_connectivity()
                tasks_before_access_blocked = 1 + exception.num_attempts

            if successful_tasks:
                pa_utils.add_weak_credentials_finding(scan_test, open_port, successful_tasks)
            else:
                service_name = SERVICES_NAMES[open_port.service]
                vuln_desc = f"No {service_name} Weak Password Found"

                if self.engine:
                    # run_engine can return without instantiating the engine
                    if self.engine.stop_reason == EngineStopReasons.SELENIUM_DRIVER_EXITED and self.do_run:
                        vuln_desc = f"Connection error during attack on {service_name} service"
                    elif self.engine.stop_reason == EngineStopReasons.LOCKOUT:
                        vuln_desc = f'Account lockout detected on {service_name} service for user "{lockout_username}"'
                    elif self.engine.stop_reason == EngineStopReasons.CAPTCHA_DETECTED:
                        vuln_desc = (
                            f"Attack stopped on {service_name} service because the web form involves a CAPTCHA check"
                        )
                    elif self.engine.stop_reason == EngineStopReasons.ACCESS_BLOCKED:
                        vuln_desc = f"Website access blocked after {tasks_before_access_blocked} failed login attempts"
                    elif self.engine.stop_reason == EngineStopReasons.FALSE_POSITIVE_DETECTED:
                        vuln_desc = f"Attack stopped on {service_name} service due to unusual responses from the target that could generate false positives"

                scan_test.set_vuln_notfound(vuln_desc, port=open_port.port, service=service_name)

            self.progress += progress_increment
            self.finish_test(scan_test)
            self.engine = None

        self.stop()

    def run_engine(
        self,
        open_port: pa_utils.OpenPort,
        usernames: list[str],
        passwords: list[str],
        attack_type: AttackType,
        monitor_engine: bool = True,
    ) -> list[AuthTask]:
        """Prepares the params, starts the Engine and the monitor thread and returns the list of successful tasks."""

        # On old Windows RDP targets, we use Ncrack for bruteforcing instead of the engine
        if open_port.service == SUPPORTED_SERVICES["RDP"] and open_port.extra.get("use_ncrack"):
            logging.info("Old Windows OS detected on RDP target - Ncrack will be used for bruteforcing")
            return self.do_ncrack_rdp_bruteforce(open_port, usernames, passwords, attack_type)

        task_generator = pa_utils.get_task_generator(open_port, usernames, passwords, self.task_id, attack_type)

        # For some services, brute forcing has already been done
        # and the result is contained in an AuthTask in open_port.extra["task"]
        if open_port.extra.get("task"):
            return [open_port.extra["task"]] if open_port.extra["task"].auth_status == AuthTask.SUCCESS else []

        # Prepare engine parameters
        # VNC bruteforcing recommends a delay is always set
        delay = 10 if open_port.service == "vnc" and self.attempts_delay < 10 else self.attempts_delay

        # If a custom delay was set, enforce using only one thread
        num_threads = 1 if self.attempts_delay > 0 else CUSTOM_NUM_THREADS.get(open_port.service, DEFAULT_NUM_THREADS)
        username_count, password_count = len(usernames), len(passwords)
        num_tasks = username_count * password_count if attack_type != AttackType.CREDENTIAL_STUFFING else username_count
        num_threads = min(num_threads, num_tasks)

        self.engine = Engine(
            self.scan_activity,
            delay,
            attack_type,
            num_threads,
            self.http_authenticator if open_port.extra.get("auth_type") == "web-form" else None,
        )

        # Use a separate thread to monitor engine progress
        if monitor_engine:
            engine_monitor_thread = Thread(
                target=self.monitor_engine,
                args=(open_port.port, num_tasks),
            )
            engine_monitor_thread.name = "Engine-Monitor"
            engine_monitor_thread.daemon = True
            engine_monitor_thread.start()

        successful_tasks = []

        # Runs the engine. When it finishes, it will return the tasks that succeeded auth
        try:
            logging.info("Now running the engine with username_count=%s", username_count)
            successful_tasks = self.engine.run(
                task_generator,
                username_count,
                self.lockout_period,
                self.attempts_per_period,
            )

        except AccountLockoutDetected as exception:
            logging.warning("Account lockout after multiple failed attempts detected")
            raise exception

        except WebsiteAccessBlocked as exception:
            logging.warning("Website access blocked after multiple failed attempts")
            raise exception

        except:
            logging.exception("Unknown engine exception")

        return successful_tasks

    def load_wordlists(self):
        """Reads the usernames and passwords wordlists from the filepaths and returns the contents"""
        try:
            with open(self.usernames_file, "r", encoding="utf-8") as usernames_file_contents:
                usernames = usernames_file_contents.readlines()
                # Remove trailing \n and duplicates
                usernames = list(set(elem.strip() for elem in usernames))

            with open(self.passwords_file, "r", encoding="utf-8") as passwords_file_contents:
                passwords = passwords_file_contents.readlines()
                # Remove trailing \n and duplicates
                passwords = list(set(elem.strip() for elem in passwords))

            logging.debug("Loaded %d usernames and %d passwords", len(usernames), len(passwords))
        except IOError:
            logging.exception("Cannot find wordlists file")
            return None, None

        return usernames, passwords

    def parse_nmap_results(self, nmap_results) -> list[pa_utils.OpenPort]:
        """
        Parses the nmap results, checks if the service is among the supported ones
        and creates an OpenPort object with the associated port information.

        Returns: a list of OpenPort objects.
        """

        open_ports: list[pa_utils.OpenPort] = []
        if not nmap_results or not nmap_results.hosts:
            logging.info("No nmap results or hosts")

            return open_ports

        server = nmap_results.hosts[0].hostname or nmap_results.hosts[0].ip_address

        # This is needed in case we find other open HTTP ports
        # besides the one of the custom login URL (e.g. 8081),
        # in which case we shouldn't use the custom URL, but the server hostname.
        #
        # The 'Custom ports' and 'Use port from target URL' options have
        # already been taken into account when performing the Nmap scan.
        if not self.custom_login_url:
            custom_login_port = None
        elif urlparse(self.custom_login_url).port:
            custom_login_port = urlparse(self.custom_login_url).port
        elif self.custom_login_url.startswith("https"):
            custom_login_port = 443
        else:
            custom_login_port = 80

        for port_info in nmap_results.hosts[0].ports:
            logging.debug("Parsing port: %s", vars(port_info))

            if port_info.port_state != "open":
                continue

            service = pa_utils.get_service_from_port_info(port_info, self.services)
            if service is None:
                continue

            extra = {
                "cpe": port_info.cpe,
                "service_product": port_info.service_product,
                "service_extrainfo": port_info.service_extrainfo,
            }

            if service.startswith("http"):
                # Check if we should use the custom login URL or the server hostname
                if not self.custom_login_url or port_info.port_number != custom_login_port:
                    url = f"{service.split('-')[0]}://{server}:{port_info.port_number}"
                    url = pa_utils.get_redirect_url(url)
                    # Check if the target supports HTTPS on this port
                    url = pa_utils.check_port_supports_https(url, port_info.port_number)
                else:
                    url = self.custom_login_url

                extra.update(
                    {
                        "url": url,
                        "auth_type": pa_utils.detect_auth_type(url),
                    }
                )

            if service == SUPPORTED_SERVICES["RDP"]:
                extra.update({"use_ncrack": False})

            open_ports.append(pa_utils.OpenPort(server, port_info.port_number, service, extra))

        return open_ports

    def monitor_engine(self, port: int, num_total_tasks: int):
        """Function run by a separate thread which monitors the Engine
        and updates the scan progress bar description."""
        while self.engine and not self.engine.started:
            logging.info("Waiting for the engine to start...")
            time.sleep(1)

        # Monitor the engine
        while self.engine and self.engine.do_run:
            msg = f"Checking for weak passwords on port {port}, {self.engine.num_processed_tasks}/{num_total_tasks}..."
            logging.info("%s (progress %i%%)", msg, self.progress)
            time.sleep(max(self.lockout_period, self.attempts_delay, 5))

    def check_default_credentials(self, open_port) -> bool:
        """
        For the open port, try to authenticate using default/common credentials from the list.
        If succeeded, creates a scan test and adds a vuln finding.
        If an account is locked out, or a WAF is detected,
        further attacks should not be carried out on the target

        Returns True or False based on whether another attack should be carried out on the port
        """

        def create_vuln_not_found_test(vuln_desc: str) -> VulnerabilityTest:
            """Creates a VulnerabilityTest with an informational finding
            for the default credentials check with the given vuln description

            Returns the VulnerabilityTest"""

            logging.info(vuln_desc)
            scan_test = self.start_test(
                f"Searching for default credentials on port {open_port.port}...",
            )
            scan_test.set_vuln_notfound(
                vuln_desc,
                port=open_port.port,
                service=open_port.service,
            )

            return scan_test

        logging.info(
            "Attempting default credentials for service %s port %d",
            open_port.service,
            open_port.port,
        )
        # Whether to continue with different attacks after the default credentials check finishes
        continue_attacks = True

        # Read the default credentials from the file
        try:
            with open(
                DEFAULT_CREDENTIALS_PATH,
                "r",
                encoding="utf-8",
            ) as default_creds_file:
                default_creds_rows = csv.reader(default_creds_file)
                matched_default_creds = pa_utils.get_default_creds_for_port(default_creds_rows, open_port)

        except (FileNotFoundError, ValueError):
            logging.exception("Error while reading the default credentials file")
            return continue_attacks

        if not matched_default_creds:
            logging.info("No default credentials to check")

            return continue_attacks

        # Run the tasks using the Engine and collect the successful ones
        usernames = [item["username"] for item in matched_default_creds]
        passwords = [item["password"] for item in matched_default_creds]

        scan_test = None
        try:
            logging.info("Attempting to run the engine with default credentials")
            successful_tasks = self.run_engine(
                open_port,
                usernames,
                passwords,
                AttackType.CREDENTIAL_STUFFING,
                monitor_engine=False,
            )
            if successful_tasks:
                scan_test = self.start_test(
                    f"Searching for default credentials on port {open_port.port}...",
                )
                pa_utils.add_weak_credentials_finding(scan_test, open_port, successful_tasks, default_creds=True)
            else:
                logging.info("No default credentials found")

        except AccountLockoutDetected as exc:
            vuln_desc = (
                f'Account lockout detected on {SERVICES_NAMES[open_port.service]} service for user "{exc.username}"'
            )
            scan_test = create_vuln_not_found_test(vuln_desc)
            continue_attacks = False

        except WebsiteAccessBlocked as exception:
            # This can only happen in WebForm tasks due to a WAF
            # We count 1 more task that corresponds to the one in check_service_connectivity()
            tasks_before_access_blocked = 1 + exception.num_attempts
            vuln_desc = f"Website access blocked after {tasks_before_access_blocked} failed login attempts"
            scan_test = create_vuln_not_found_test(vuln_desc)
            continue_attacks = False

        if scan_test:
            self.finish_test(scan_test)

        return continue_attacks

    def do_ncrack_rdp_bruteforce(
        self, open_port: pa_utils.OpenPort, usernames: list[str], passwords: list[str], attack_type: AttackType
    ) -> list[RdpTask]:
        """
        Custom made function for RDP service bruteforcing on old Windows versions using Ncrack
        Works differently based on AttackType:
            Dictionary          -> runs a single Ncrack process using the wordlists on disk
            Credential stuffing -> same as dictionary, with paired credentials
            Password-Spray      -> runs a separate Ncrack process for each burst of credentials, sleeping between bursts
        Returns a list of tasks with successful login
        """

        if attack_type == AttackType.DICTIONARY:
            # For Dictionary attacks, username and password fields are passed as wordlist paths on the disk
            rdp_task = RdpTask(1, open_port.server, open_port.port, self.usernames_file, self.passwords_file)
            rdp_task.ncrack_connect(attempts_delay=self.attempts_delay, creds_as_wordlists=True)
            return [rdp_task] if rdp_task.auth_status == AuthTask.SUCCESS else []

        if attack_type == AttackType.CREDENTIAL_STUFFING:
            # For Credential stuffing and Password spray attacks, username and password fields are passed as lists
            rdp_task = RdpTask(1, open_port.server, open_port.port, usernames, passwords)
            rdp_task.ncrack_connect(attempts_delay=self.attempts_delay, creds_as_wordlists=False, creds_as_pairs=True)
            return [rdp_task] if rdp_task.auth_status == AuthTask.SUCCESS else []

        if attack_type == AttackType.PASSWORD_SPRAY:
            successful_tasks = []
            start_idx = 0
            password_count = len(passwords)

            while start_idx < password_count:
                end_idx = min(start_idx + self.attempts_per_period, password_count)
                current_period_passwords = passwords[start_idx:end_idx]

                rdp_task = RdpTask(1, open_port.server, open_port.port, usernames, current_period_passwords)
                # Maybe the timeout here should be smaller than the default 3600 or based on max_scan_time
                rdp_task.ncrack_connect(attempts_delay=self.attempts_delay, creds_as_wordlists=False)

                if rdp_task.auth_status == AuthTask.SUCCESS:
                    successful_tasks.append(rdp_task)

                if len(successful_tasks) >= MAX_CREDENTIALS_FOUND:
                    logging.info("Stopping Ncrack password spray -- MAX_CREDENTIALS_FOUND was reached")
                    break

                start_idx += self.attempts_per_period
                if start_idx > password_count:
                    break

                logging.info("Waiting for lockout period to pass (%d seconds)...", self.lockout_period)
                time.sleep(self.lockout_period)

            return successful_tasks

        return []

    def stop(self):
        """Function that makes sure the current running engine
        and selenium container used by the http_authenticator are stopped"""
        # This is set in case scan is stopped during the default credentials attack
        # So that starting a second engine can be avoided
        self.do_run = False

        if self.engine:
            # Don't set engine to None because engine.stop_reason might be needed
            self.engine.stop_queue()

        # If http_authenticator is initialized, it will also stop the selenium container
        if self.http_authenticator:
            self.http_authenticator.stop()
            self.http_authenticator = None

        # Check if scan was stopped before http_authenticator was fully initialized but after the container started
        elif self.selenium_container:
            try:
                self.selenium_container.stop()
            except:
                pass

            self.selenium_container = None

    def __del__(self):
        """Make sure the Selenium container is stopped when the class object is deleted"""
        self.stop()


def main():
    """Constructs the argparser, inits the tool and runs it."""

    set_logger()
    logging.getLogger("urllib3").setLevel(logging.ERROR)
    logging.getLogger("pika").propagate = False
    logging.getLogger("stomp").setLevel(logging.ERROR)
    logging.getLogger("selenium.webdriver.remote.remote_connection").setLevel(logging.WARNING)
    logging.getLogger("tldextract").setLevel(logging.WARNING)
    logging.getLogger("pypsrp").setLevel(logging.WARNING)
    logging.getLogger("filelock").setLevel(logging.WARNING)

    parser = argparse.ArgumentParser()
    parser.add_argument("--target", required=True, help="IP or hostname to scan")
    parser.add_argument(
        "--attack-type",
        default=AttackType.DICTIONARY.value,
        choices=[attack_type.value for attack_type in AttackType],
        help="the type of attack which password auditor will perform",
    )
    parser.add_argument(
        "--services",
        default=",".join(SUPPORTED_SERVICES.keys()),
        help=",".join(SUPPORTED_SERVICES.keys()),
    )
    parser.add_argument("--usernames-file", default=DEFAULT_USERNAMES_FILE, help="path to the usernames file on disk")
    parser.add_argument("--passwords-file", default=DEFAULT_PASSWORDS_FILE, help="path to the passwords file on disk")
    parser.add_argument("--login-url", default="", help="custom URL to try to login to")
    parser.add_argument("--ports", default="", help="a list of custom ports to scan, e.g. '80,443'. default: top 100")
    parser.add_argument(
        "--attempts-delay",
        type=int,
        default=0,
        help="time delay (in seconds) between two consecutive attempts. default: 0 (no delay)",
    )
    parser.add_argument(
        "--lockout-period",
        type=int,
        default=DEFAULT_LOCKOUT_PERIOD,
        help=(
            "(password-spray attack type only) the time (in minutes) to wait for account lockout to reset. "
            f"Must be between 1 and 1440. Default: {DEFAULT_LOCKOUT_PERIOD}"
        ),
    )
    parser.add_argument(
        "--attempts-per-period",
        type=int,
        default=DEFAULT_ATTEMPTS_PER_PERIOD,
        help=(
            "(password-spray attack type only) the number of passwords to try on each user for each lockout period. "
            f"Must be between 1 and 50000. Default: {DEFAULT_ATTEMPTS_PER_PERIOD}"
        ),
    )
    parser.add_argument(
        "--check-default-creds",
        action="store_true",
        help="try default/common credentials first, for each respective service",
    )

    args = parser.parse_args()
    custom_ports = args.ports.replace(" ", "")
    if custom_ports == "":
        custom_ports = None

    scanner = PasswordAuditor(
        args.target,
        args.services,
        args.usernames_file,
        args.passwords_file,
        args.login_url,
        custom_ports,
        args.attempts_delay,
        args.check_default_creds,
        AttackType(args.attack_type),
        args.lockout_period,
        args.attempts_per_period,
    )
    if not scanner.init():
        if scanner.task_status != TaskStatus.CONN_ERROR:
            logging.error("Could not start Password Auditor")
        sys.exit()

    logging.info("Password Auditor started: %s", str(sys.argv[1:]))
    scanner.run()


if __name__ == "__main__":
    main()
