class Globals:
    """Globals class"""

    redis_creds: dict[str, str] = {}
    max_scan_activity_items = 100

class TaskBase(object):
    """TaskBase is the base class for any scanner. It ensures various services such as:
    - communication with the Redis database (output update, stop)
    - container for test objects
    - returning the scan results in JSON format
    - self timeout"""
    def __init__(self, scan_type):
        self.tests = []
        self.task_status = TaskStatus.STARTED
        self.scan_type = scan_type  # discovery or vulnerability
        self.standalone = False
        self.start_time = time.localtime()
        self.end_time = time.localtime()
        self.disclaimer = ""
        self.task_id = None
        self.task_key = None
        self.do_run = True
        self.progress = 0
        self.wait = False
        self.stop_reason = None
        self.communicator_thread = None
        self._stats = {}  # dictionary for showing statistics after the scan has finished
        self.info_text: str = ""  # alerts displayed in the beginning of the scan only in platform report
        self.redis = None
        self.selenium_interface = None
        self.vpn_connection = None
        self.is_vpn = False
        self.max_scan_time = None

        try:
            sentry.setup()  # monitor exceptions
        except Exception:
            logging.exception("Failed to setup sentry")

        # This contains a list of items to be shown in the web interface
        # to show what is the scanner doing in real time
        self.scan_activity = ScanActivity()

        # Obtain the child class that was derived from TaskBase so
        # we can automatically find how many tests it has implemented
        if self.scan_type == "discovery":
            cls_obj = TaskBase.__subclasses__()[0].__subclasses__()[0]
        elif self.scan_type == "vulnerability":
            cls_obj = TaskBase.__subclasses__()[1].__subclasses__()[0]
        else:
            raise NotImplementedError()
        self.num_tests = get_num_tests(cls_obj)

        # Disable urllib3's InsecurePlatformWarning: A true SSLContext object is not available.
        # This can also be done by running the command: pip install requests[security]
        urllib3.disable_warnings()

        # Read the configuration file
        try:
            cfg_file = "/var/www/pentest-tools/global_configs/pentesttools.cfg"
            parser = ConfigParser()
            parser.read(cfg_file)

            Globals.redis_creds.update({"host": parser.get("redis", "host")})
            Globals.redis_creds.update({"port": parser.get("redis", "port")})
            Globals.redis_creds.update({"pass": parser.get("redis", "pass")})

        except Exception:
            logging.exception("Config reading error.")
            sys.exit()

    def communicate(self):
        """This thread continuously communicates with the Redis database.
        It has mainly three functionalities:
        - send the output to the database periodically
        - receive stop commands and act accordingly
        - detect self timeouts and stop accordingly"""
        try:
            prev_scan_tests = ""
            prev_progress = "0"

            while True:
                # Write the output to Redis only if it has changed
                dict_output = self.dict_output()
                scan_tests = json.dumps(dict_output["scan_tests"])
                progress = dict_output["scan_info"]["progress"]

                if scan_tests != prev_scan_tests or progress != prev_progress:
                    # Send output to Redis
                    task_data = {"output": json.dumps(dict_output), "scan_info": json.dumps(dict_output["scan_info"])}

                    if prev_scan_tests == "":
                        # Ask for status update only for the first time\ TaskStatus.STARTED
                        task_data.update({"status": self.task_status, "db_status_updated": "0"})

                    prev_scan_tests = scan_tests
                    prev_progress = progress

                    hmset_if_exists(self.redis, self.task_key, task_data, self.scan_activity.pop_items())

                else:
                    # The actual output of the scan or the progress have not changed so we don't want to send the full output to Redis.
                    # In this case, we send only the scan_activity.
                    task_data = {}
                    hmset_if_exists(self.redis, self.task_key, task_data, self.scan_activity.pop_items())

                # Check if the user has requested to stop this task
                stop_task = self.redis.srem("to_stop_tasks", self.task_id)

                # Stop this task
                if stop_task >= 1:
                    reason = self.redis.hget("task:" + self.task_id, "stop_reason")
                    logging.debug("Stopping task: %s, reason: %s", self.task_id, reason)

                    # Set status according to the stop_reason
                    if reason == "timeout":
                        self.task_status = TaskStatus.TIMED_OUT
                    elif reason == "user set timeout":
                        self.add_info_text(
                            "The scan was stopped because the custom maximum scan time was reached"
                            + (f" ({int(self.max_scan_time/60)} minutes)." if self.max_scan_time is not None else ".")
                        )
                        self.task_status = TaskStatus.FINISHED
                    else:
                        self.task_status = TaskStatus.STOPPED_BY_USER

                    logging.debug("Task status: %d", self.task_status)

                    if self.task_status is None:
                        logging.error("Stopped with unknown reason")

                    # Call the specific stop method of each scanner (if implemented)
                    self.stop_with_timeout()

                    if self.vpn_connection:
                        self.vpn_connection.pre_down()

                    # Some tools react to the stop signal and change their output accordingly. We have to update the dict_outout
                    dict_output = self.dict_output()

                    # Update the status in Redis
                    task_data = {
                        "status": self.task_status,
                        "db_status_updated": "0",
                        "output": json.dumps(dict_output),
                        "scan_info": json.dumps(dict_output["scan_info"]),
                    }
                    hmset_if_exists(self.redis, self.task_key, task_data)

                    # Remove the task from running_tasks
                    self.redis.lrem("running_tasks", self.task_id)
                    self.redis.lpush("finished_tasks", self.task_id)

                    # Maybe we should do this more nicely
                    self.do_run = False
                    kill_all_child_procs()
                    logging.debug("Sending to Redis - FINISHED")
                    os._exit(1)

                # The tool has finished and it is waiting to exit
                if self.wait is True:
                    # Send the latest output to Redis
                    if self.task_status == TaskStatus.STARTED:
                        self.task_status = TaskStatus.FINISHED
                    else:
                        # Pass the status set by the tool (ex. ABORTED)
                        pass

                    if self.vpn_connection:
                        self.vpn_connection.pre_down()

                    self.progress = 100
                    dict_output = self.dict_output()

                    while True:
                        if self.redis.hsetnx(self.task_key, "db_status_updated_lock", "communicator"):
                            break

                        logging.debug("db_status_updated_lock not acquired")
                        time.sleep(5)

                    # Update the status in Redis
                    task_data = {
                        "status": self.task_status,
                        "db_status_updated": "0",
                        "output": json.dumps(dict_output),
                        "scan_info": json.dumps(dict_output["scan_info"]),
                    }
                    hmset_if_exists(self.redis, self.task_key, task_data)

                    self.redis.hdel(self.task_key, "db_status_updated_lock")

                    # Remove the task from running_tasks
                    self.redis.lrem("running_tasks", self.task_id)
                    self.redis.lpush("finished_tasks", self.task_id)

                    logging.debug("Sending to Redis - FINISHED")
                    # logging.debug(json.dumps(dict_output))

                    self.wait = False
                    break

                time.sleep(1)
        except Exception as exc:
            logging.exception("Communicator thread exception.")
            try:
                if isinstance(exc, UnicodeDecodeError):
                    # delete the output if it caused trouble
                    dict_output["scan_tests"] = {}

                if self.vpn_connection:
                    self.vpn_connection.pre_down()

                self.task_status = TaskStatus.ABORTED

                # Update the status in Redis
                task_data = {
                    "status": self.task_status,
                    "db_status_updated": "0",
                    "output": json.dumps(dict_output),
                    "scan_info": json.dumps(dict_output["scan_info"]),
                }
                hmset_if_exists(self.redis, self.task_key, task_data)

                # Remove the task from running_tasks
                self.redis.lrem("running_tasks", self.task_id)
                self.redis.lpush("finished_tasks", self.task_id)

                self.stop_with_timeout()
                self.do_run = False
            except Exception:
                logging.exception("Internal error exception.")

            kill_all_child_procs()
            os._exit(1)

class VulnerabilityScanner(TaskBase):
    """Scanner types used for vulnerability scanner. Ex: website_scanner, network_scanner
    The thread lock is needed for len(self.tests) in start_test"""

    def __init__(self):
        TaskBase.__init__(self, "vulnerability")
        self.start_test_lock = threading.Lock()

    def start_test(self, test_description: str, test_name: str = "default") -> VulnerabilityTest:
        self.start_test_lock.acquire()
        scan_test = VulnerabilityTest(test_description, len(self.tests), test_name)
        self.tests.append(scan_test)
        self.start_test_lock.release()
        return scan_test

    def run(self):
        raise NotImplementedError()