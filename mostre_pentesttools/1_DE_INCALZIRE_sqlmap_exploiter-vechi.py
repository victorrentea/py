"""
This is the main module of the SQLi Exploiter tool.

For Victor:
This tool (sqlmap Exploiter) calls the CLI tool called sqlmap (check construct_command())
which is used to detect SQL injection vulnerabilities. It then parses the output of the process.

This is one of the simpler tools.
"""
import argparse
import base64
import logging
import re
import signal
import subprocess
import sys
from collections import namedtuple
from typing import NamedTuple

from shellescape import quote

from tools.core.scanner_base import DiscoveryScanner
from tools.core.task_base import TaskStatus, set_logger

sys.excepthook = lambda *args:\
    logging.critical("Uncaught exception:", exc_info=args)

EVIDENCE_INDEX = 4

XTERM_CONTROL_STRING = "\u001B"

ALLOWED_TAMPER_VALUES = [
    "",
    "between",
    "charencode",
    "equaltolike",
    "space2comment",
    "base64_encode",
]
# ALLOWED_DBMS_VALUE = parse_json("comun cu php.json")
ALLOWED_DBMS_VALUES = [
    "",
    "MySQL",
    "Oracle",
    "PostgreSQL",
    "Microsoft SQL Server",
    "Microsoft Access",
    "IBM DB2",
    "SQLite",
    "Firebird",
    "Sybase",
    "SAP MaxDB",
    "HSQLDB",
    "Informix",
]
from dataclasses import dataclass, field


# poti si mai prost: list((str, str)) in loc de namedtuple

# poti si mai prost: dict[str, str] in loc de namedtuple

#PROST - a nu se folosi. e div vremuri cand nu aveam type hints!!!
# SQLIType = namedtuple("SQLIType", ["type", "title", "payload"])

class SQLIType(NamedTuple):
    type: str
    title: str
    payload: str

@dataclass(frozen=True)  # frozen=True -> imutabil ❤️
# e mai bun pt ca implementeaza default si __str__, __eq__, __hash__, __repr__
# folosim asta daca vrem si altceva decat __init__ sau vrem sa le facem imutabile
class VulnParamData:
    name: str
    http_method: str
    sqli_types: list[dict[str, str]] = field(default_factory=list)
    bou: bool = True
    # sieu: str# nu are voie sa apara asta intr-o subclasa => in dataclass care vor sa permita subclasare nu ai voie sa folosesti parametrii default
    # sau: nu face dataclass parinti
    # sau: nu mai exinde clase. e vechi.. rau. => favor composition over inheritance

    def __post_init__(self):
        if (len(self.name) < 3):
            raise ValueError("Name must be at least 3 characters long")

# pot face OOP intr-o clasa, nu intr-un tuplu.
class SQLIType:
    def __init__(self, type: str, title: str, payload: str):
        self.type = type
        self.title = title
        self.payload = payload




@dataclass(frozen=True)  # frozen=True -> imutabil
# e mai bun pt ca implementeaza default si __str__, __eq__, __hash__, __repr__
# folosim asta daca vrem si altceva decat __init__ sau vrem sa le facem imutabile
class VulnParam:
    name: str
    http_method: str
    sqli_types: list[dict[str, str]] = field(default_factory=list)

    def add_sqli_type(self, sqli_type: str):
        new_sqli_type = {
            "type": sqli_type,
            "title": "",
            "payload": "",
        }
        self.sqli_types.append(new_sqli_type)


    def update_last_sqli_type_title(self, title: str = ""):
        if title != "":
            self.sqli_types[-1]["title"] = title

    def update_last_sqli_type_payload(self, payload: str):
        if payload != "":
            self.sqli_types[-1]["payload"] = payload


class SQLiExploiter(DiscoveryScanner):
    """This class implements the SQLi Exploiter tool"""

    def __init__(self, target: str, cmd: str, extract_options: dict, scan_type: str):
        self.tool_name: str = "SQLi Exploiter"
        self.target: str = target
        self.cmd: str = cmd
        self.extract_options: dict = extract_options
        self.scan_type: str = scan_type
        self.progress = 0

        DiscoveryScanner.__init__(self)

    def run(self):
        """This method calls each function that implements a test, in the desired order."""

        try:
            # Do the actual scan
            self.testfunc___doscan()

            # Wait for TaskAgent to collect the output, then exit
            logging.debug("Waiting...")
            self.wait_to_finish()
            logging.debug("Finished")

        except:
            logging.exception("Unkown exception in run() method")

    XTERM_CONTROL_STRING = "\u001B"
    """Skip lines which start with \u001B is a control string for xterm that sqlmap prints and doesn't offer an option to disable"""

    def testfunc___doscan(self):
        """This method implements a test performed within a scan."""

        with self.start_test("Scanning target(s)...") as test_obj:
            logging.info("Running command: %s", self.cmd)
            #vis: with process...  :
            process:subprocess.Popen = subprocess.Popen(
                self.cmd,
                shell=True,
                stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT,
                close_fds=True,
                encoding="utf-8",
            )
            self.progress = 50
            output_lines = self.collect_output(process, test_obj)
            self.kill_process(process)
            vuln_params = self._parse_vuln_params(output_lines) # pure💪
            available_data = self.parse_available_data(output_lines) # pure💪
            self.fill_results(available_data, test_obj, vuln_params)

# ce misto ar fi daca ati avea un concept (Tuple, class) numit Table{caption, headers, data}
    def fill_results(self, available_data, test_obj, vuln_params) :
        test_obj.set_headers(["Parameter", "Method", "SQLi Type", "Payload", "Extracted data"])
        if not vuln_params:
            test_obj.set_caption("SQL Injection NOT Found")
            # Displayed in UI
            test_obj.add_data_row(["-", "-", "-", "-", "-"])
        else:
            test_obj.set_caption("SQL Injection Exploited Successfully")
            for param in vuln_params:
                for sqli_type in param.sqli_types:
                    test_obj.add_data_row(
                        [
                            param.name,
                            param.http_method,
                            sqli_type["type"],
                            f'<span class="sqli-exploiter-payload">{sqli_type["payload"]}</span>',
                            "-",
                        ]
                    )
            # imagine: SCAN_TYPE_FREE (constanta) sau chiar ScanType.FREE (enum ftw)
            if self.scan_type == "free":
                # hide data (business teaser)
                extracted_data = "-"
            else:
                # lamurti-va frate: cine formateaza? PHP. iar in api response catre clienti te rad curcile daca trimit HTML
                extracted_data = "\n\n".join(
                    [f"{key}: <strong>{value}</strong>" for key, value in available_data.items()]
                )
            test_obj.output_data[0][EVIDENCE_INDEX] = extracted_data
            # test_obj.tool_extensions = extracted_data

    def collect_output(self, process, test_obj):
        output_lines = []
        for line in process.stdout:
            if line.startswith(self.XTERM_CONTROL_STRING):
                continue

            # **** Prevent path disclosure *****
            # TODO risc: daca Doamne fereste deployem in alt folder -> toolul vostru de sec are vulnerabilitati.
            if "/var/www/" not in line:
                test_obj.raw_output += line
            output_lines.append(line)
        return output_lines

    def parse_available_data(self, output_lines):
        available_data = {}
        for line in output_lines:
            if self.extract_options["user"]:
                match = re.search(r"current user: '(.+)'", line)
                if match:
                    available_data["Current user"] = match.group(1)

            # imagine enum!
            if self.extract_options["db"]:
                match = re.search(r"current database: '(.+)'", line)
                if match:
                    available_data["Current database"] = match.group(1)

            if self.extract_options["host"]:
                match = re.search(r"hostname: '(.+)'", line)
                if match:
                    available_data["Server hostname"] = match.group(1)

            match = re.search(r"back-end DBMS: (.+)", line)
            if match:
                available_data["Database type"] = match.group(1)

            match = re.search(r"web server operating system: (.+)", line)
            if match:
                available_data["Operating system"] = match.group(1)

            match = re.search(r"web application technology: (.+)", line)
            if match:
                available_data["Server technology"] = match.group(1)
        logging.debug("Extracted data : %s", available_data)
        return available_data

    @staticmethod
    def _parse_vuln_params(output_lines):
        vuln_params = []
        for line in output_lines:
            # A new parameter is defined by a line as follows: Parameter: <name> <method>
            match = re.search(r"^Parameter: (.+) \((POST|GET)\)", line)
            if match:
                vuln_params.append(VulnParam(match.group(1), match.group(2)))

            # Lines following a new parameter describe the sqli typeS this param is vulnerable to
            match = re.search(r"Type: (.+)", line)
            last_vuln_param = vuln_params[-1]
            if match and vuln_params:
                last_vuln_param.add_sqli_type(match.group(1))

            match = re.search(r"Title: (.+)", line)
            if match and vuln_params:
                last_vuln_param.sqli_types[-1]["title"] = match.group(1)

            match = re.search(r"Payload: (.+)", line)
            if match and vuln_params:
                last_vuln_param.sqli_types[-1]["payload"] = match.group(1)
        return vuln_params

    def kill_process(self, proc: subprocess.Popen):
        try:

            def alarm_handler(signum, frame):
                """Function used to raise the alarm signal."""
                raise TimeoutError("Process takes too long!")

            signal.signal(signal.SIGALRM, alarm_handler)
            signal.alarm(2)  # seconds
            logging.debug("Waiting for process: pid=%i, cmd=%s", proc.pid, self.cmd)
            proc.wait()
            logging.debug("Process finished")
            signal.alarm(0)

        except:
            logging.exception("Killing pid %i", proc.pid)
            try:
                proc.kill()
            except:
                pass


def construct_command(args) -> str:
    """Parses the argument options and returns the sqlmap command to be run."""

    cmd = (
        "python /var/www/pentest-tools/tools/external/sqlmap_inst/sqlmap/sqlmap.py --disable-coloring --flush-session "
        "--batch --random-agent --answers others=Y,problems=Y,sitemap=Y "
        f'--url {quote(base64.b64decode(args.target).decode("utf-8"))} --method {args.method} '
        f'--data {quote(base64.b64decode(args.post_data).decode("utf-8"))} '
        f"--level={args.detection_level} --risk={args.detection_risk} --technique={quote(args.techniques)}"
    )

    if args.cookie:
        cmd += f' --cookie={quote(base64.b64decode(args.cookie).decode("utf-8"))}'

    if args.http_code > 0:
        cmd += f" --code={args.http_code}"

    if args.dbms:
        cmd += f" --dbms={args.dbms}"

    if args.tamper_script:
        cmd += f" --tamper={args.tamper_script}"

    if args.payload_prefix:
        cmd += f' --prefix={quote(base64.b64decode(args.payload_prefix).decode("utf-8"))}'

    if args.payload_suffix:
        cmd += f' --suffix={quote(base64.b64decode(args.payload_suffix).decode("utf-8"))}'

    if args.extract_user:
        cmd += " --current-user"

    if args.extract_db:
        cmd += " --current-db"

    if args.extract_host:
        cmd += " --hostname"

    if args.test_params:
        cmd += f" -p {quote(args.test_params)}"

    if args.light_crawling:
        cmd += " --crawl=2"

    return cmd


def main():
    """Entry point of the script"""

    set_logger()
    logging.getLogger("requests").setLevel(logging.WARNING)
    logging.getLogger("urllib3").setLevel(logging.WARNING)

    parser = argparse.ArgumentParser()
    parser.add_argument("--target", required=True, help="URL to scan, base64 encoded")
    parser.add_argument("--method", choices=["GET", "POST"], default="GET", help="HTTP method, default GET")
    parser.add_argument("--post-data", default="", help="POST data, base64 encoded")
    parser.add_argument("--cookie", default="", help="cookie header, base64 encoded")
    parser.add_argument("--http-code", type=int, default=0, help="HTTP code to match when a query is evaluated to True")
    parser.add_argument(
        "--detection-level", type=int, choices=range(1, 6), default=1, help="diversity level of tests, default 1"
    )
    parser.add_argument(
        "--detection-risk",
        type=int,
        choices=range(1, 4),
        default=1,
        help="aggressiveness level, default 1 (not offensive). 2 adds time based queries, 3 adds OR injections",
    )
    parser.add_argument(
        "--tamper-script",
        choices=ALLOWED_TAMPER_VALUES,
        default="",
        help="use given script for tampering injection data",
    )
    parser.add_argument("--dbms", choices=ALLOWED_DBMS_VALUES, default="", help="test for a specific dbms")
    parser.add_argument("--techniques", default="BEUSTQ", help="SQLi techniques to use, default BEUSTQ (all)")
    parser.add_argument("--payload-prefix", default="", help="string to prepend to each payload, base64 encoded")
    parser.add_argument("--payload-suffix", default="", help="string to append to each payload, base64 encoded")
    parser.add_argument("--extract-user", action="store_true", help="retrieve DBMS current user")
    parser.add_argument("--extract-db", action="store_true", help="retrieve DBMS current database")
    parser.add_argument("--extract-host", action="store_true", help="retrieve DBMS server hostname")
    parser.add_argument("--test-params", default="", help="testable parameters, e.g. id,pass")
    parser.add_argument("--light-crawling", action="store_true", help="performs crawling with depth 2")
    parser.add_argument("--scan-type", choices=["deep", "free"], default="deep", help="whether to perform a scan for a free user, default deep",)
    args = parser.parse_args()

    # Initialize the scanner
    # It connects to the Task Agent and waits for requests from there
    scanner = SQLiExploiter(
        base64.b64decode(args.target).decode("utf-8"),
        construct_command(args),
        {
            "user": args.extract_user,
            "db": args.extract_db,
            "host": args.extract_host,
            "free": args.scan_type == "free",
        },
        args.scan_type,
        # args
    )

    if not scanner.init():
        if scanner.task_status != TaskStatus.CONN_ERROR:
            logging.error("Could not start SQLi Exploiter")
        sys.exit()

    logging.info("SQLi Exploiter started: %s", sys.argv)

    # Run the tests and wait for output to be collected by Task Agent
    scanner.run()


if __name__ == "__main__":
    main()
