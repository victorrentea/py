"""
This is the main module of the SQLi Exploiter tool.

For Victor:
This tool (sqlmap Exploiter) calls the CLI tool called sqlmap (check construct_command())
which is used to detect SQL injection vulnerabilities. It then parses the output of the process.

This is one of the simpler tools.
"""
import argparse
import base64
import logging
import re
import signal
import subprocess
import sys

from shellescape import quote

from tools.core.scanner_base import DiscoveryScanner
from tools.core.task_base import TaskStatus, set_logger

ALLOWED_TAMPER_VALUES = [
    "",
    "between",
    "charencode",
    "equaltolike",
    "space2comment",
    "base64_encode",
]
ALLOWED_DBMS_VALUES = [
    "",
    "MySQL",
    "Oracle",
    "PostgreSQL",
    "Microsoft SQL Server",
    "Microsoft Access",
    "IBM DB2",
    "SQLite",
    "Firebird",
    "Sybase",
    "SAP MaxDB",
    "HSQLDB",
    "Informix",
]


class VulnParam:
    """Holds the information about a vulnerable parameter found."""

    def __init__(self, name: str, http_method: str):
        self.name: str = name
        self.http_method: str = http_method
        self.sqli_types: list[dict[str, str]] = []

    def add_sqli_type(self, sqli_type: str):
        """Adds a new sqli_type to the sqli_types attribute list."""

        new_sqli_type = {
            "type": sqli_type,
            "title": "",
            "payload": "",
        }
        self.sqli_types.append(new_sqli_type)

    def update_last_sqli_type(self, title: str = "", payload: str = ""):
        """Updates the last element of the sqli_types attribute list with the given title and payload, if not empty."""

        if title != "":
            self.sqli_types[-1]["title"] = title
        if payload != "":
            self.sqli_types[-1]["payload"] = payload


class SQLiExploiter(DiscoveryScanner):
    """This class implements the SQLi Exploiter tool"""

    def __init__(self, target: str, cmd: str, extract_options: dict, scan_type: str):
        self.tool_name: str = "SQLi Exploiter"
        self.target: str = target
        self.cmd: str = cmd
        self.extract_options: dict = extract_options
        self.scan_type: str = scan_type
        self.progress = 0

        DiscoveryScanner.__init__(self)

    def run(self):
        """This method calls each function that implements a test, in the desired order."""

        try:
            # Do the actual scan
            self.testfunc___doscan()

            # Wait for TaskAgent to collect the output, then exit
            logging.debug("Waiting...")
            self.wait_to_finish()
            logging.debug("Finished")

        except:
            logging.exception("Unkown exception in run() method")

    def testfunc___doscan(self):
        """This method implements a test performed within a scan."""

        # Obtain a new test object - it contains all info about this test
        test_obj = self.start_test("Scanning target(s)...")

        # Do the testing work
        try:
            current_user = ""
            current_db = ""
            hostname = ""
            db_type = ""
            operating_system = ""
            server_technology = ""

            logging.info("Running command: %s", self.cmd)
            proc = subprocess.Popen(
                self.cmd,
                shell=True,
                stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT,
                close_fds=True,
                encoding="utf-8",
            )

            vuln_params = []

            self.progress = 50
            # Get output until it's finished
            while True:
                line = proc.stdout.readline()

                # Skip lines which start with \u001B
                # (it's a control string for xterm that sqlmap prints and doesn't offer an option to disable)
                if line.startswith("\u001B"):
                    continue

                # A new parameter is defined by a line as follows: Parameter: <name> <method>
                match = re.search(r"^Parameter: (.+) \((POST|GET)\)", line)
                if match:
                    vuln_params.append(VulnParam(match.group(1), match.group(2)))

                # Lines following a new parameter describe the sqli types this param is vulnerable to
                match = re.search(r"Type: (.+)", line)
                if match and vuln_params:
                    vuln_params[-1].add_sqli_type(match.group(1))

                match = re.search(r"Title: (.+)", line)
                if match and vuln_params:
                    vuln_params[-1].update_last_sqli_type(title=match.group(1))

                match = re.search(r"Payload: (.+)", line)
                if match and vuln_params:
                    vuln_params[-1].update_last_sqli_type(payload=match.group(1))

                if self.extract_options["user"]:
                    match = re.search(r"current user: '(.+)'", line)
                    if match:
                        current_user = match.group(1)
                        logging.debug("User extracted: %s", current_user)

                if self.extract_options["db"]:
                    match = re.search(r"current database: '(.+)'", line)
                    if match:
                        current_db = match.group(1)
                        logging.debug("Database extracted: %s", current_db)

                if self.extract_options["host"]:
                    match = re.search(r"hostname: '(.+)'", line)
                    if match:
                        hostname = match.group(1)
                        logging.debug("Hostname extracted: %s", hostname)

                match = re.search(r"back-end DBMS: (.+)", line)
                if match:
                    db_type = match.group(1)
                    logging.debug("DBMS extracted: %s", db_type)

                match = re.search(r"web server operating system: (.+)", line)
                if match:
                    operating_system = match.group(1)
                    logging.debug("OS extracted: %s", operating_system)

                match = re.search(r"web application technology: (.+)", line)
                if match:
                    server_technology = match.group(1)
                    logging.debug("Server technology extracted: %s", server_technology)

                if not line:
                    break  # Finished

                # Prevent path disclosure
                if not "/var/www/" in line:
                    test_obj.raw_output += line

            # Make sure the process is terminated before continuing
            try:

                def alarm_handler(signum, frame):
                    """Function used to raise the alarm signal."""
                    raise TimeoutError("Process takes too long!")

                signal.signal(signal.SIGALRM, alarm_handler)
                signal.alarm(2)  # seconds
                logging.debug("Waiting for process: pid=%i, cmd=%s", proc.pid, self.cmd)
                proc.wait()
                logging.debug("Process finished")
                signal.alarm(0)

            except:
                logging.exception("Killing pid %i", proc.pid)
                try:
                    proc.kill()
                except:
                    pass

            # Create the test results
            test_obj.set_headers(["Parameter", "Method", "SQLi Type", "Payload", "Extracted data"])

            if not vuln_params:
                test_obj.set_caption("SQL Injection NOT Found")
                # Show a line with empty values if nothing was found
                test_obj.add_data_row(["-", "-", "-", "-", "-"])

                return

            test_obj.set_caption("SQL Injection Exploited Successfully")

            # Concatenate parameter names, separated by a comma
            for param in vuln_params:
                for sqli_type in param.sqli_types:
                    test_obj.add_data_row(
                        [
                            param.name,
                            param.http_method,
                            sqli_type["type"],
                            f'<span class="sqli-exploiter-payload">{sqli_type["payload"]}</span>',
                            "-",
                        ]
                    )

            # If it's a free scan, don't show any extracted data
            if self.scan_type == "free":
                extracted_data = "-"
            else:
                available_data = {
                    "Current database": current_db,
                    "Current user": current_user,
                    "Operating system": operating_system,
                    "Server technology": server_technology,
                    "Database type": db_type,
                    "Server hostname": hostname,
                }
                extracted_data = "\n\n".join(
                    [f"{key}: <strong>{value}</strong>" for key, value in available_data.items() if value]
                )

            # Add extracted info to the first parameter
            test_obj.output_data[0][4] = extracted_data

        except:
            logging.exception("Unknown exception")

        finally:
            # Always finish the test
            logging.debug(
                "Raw data: %s\nHeaders: %s\nOutput_data: %s\n",
                test_obj.raw_output,
                test_obj.headers,
                test_obj.output_data,
            )
            self.finish_test(test_obj)


def construct_command(args) -> str:
    """Parses the argument options and returns the sqlmap command to be run."""

    cmd = (
        "python /var/www/pentest-tools/tools/external/sqlmap_inst/sqlmap/sqlmap.py --disable-coloring --flush-session "
        "--batch --random-agent --answers others=Y,problems=Y,sitemap=Y "
        f'--url {quote(base64.b64decode(args.target).decode("utf-8"))} --method {args.method} '
        f'--data {quote(base64.b64decode(args.post_data).decode("utf-8"))} '
        f"--level={args.detection_level} --risk={args.detection_risk} --technique={quote(args.techniques)}"
    )

    if args.cookie:
        cmd += f' --cookie={quote(base64.b64decode(args.cookie).decode("utf-8"))}'

    if args.http_code > 0:
        cmd += f" --code={args.http_code}"

    if args.dbms:
        cmd += f" --dbms={args.dbms}"

    if args.tamper_script:
        cmd += f" --tamper={args.tamper_script}"

    if args.payload_prefix:
        cmd += f' --prefix={quote(base64.b64decode(args.payload_prefix).decode("utf-8"))}'

    if args.payload_suffix:
        cmd += f' --suffix={quote(base64.b64decode(args.payload_suffix).decode("utf-8"))}'

    if args.extract_user:
        cmd += " --current-user"

    if args.extract_db:
        cmd += " --current-db"

    if args.extract_host:
        cmd += " --hostname"

    if args.test_params:
        cmd += f" -p {quote(args.test_params)}"

    if args.light_crawling:
        cmd += " --crawl=2"

    return cmd


def main():
    """Entry point of the script"""

    set_logger()
    logging.getLogger("requests").setLevel(logging.WARNING)
    logging.getLogger("urllib3").setLevel(logging.WARNING)

    parser = argparse.ArgumentParser()
    parser.add_argument("--target", required=True, help="URL to scan, base64 encoded")
    parser.add_argument("--method", choices=["GET", "POST"], default="GET", help="HTTP method, default GET")
    parser.add_argument("--post-data", default="", help="POST data, base64 encoded")
    parser.add_argument("--cookie", default="", help="cookie header, base64 encoded")
    parser.add_argument("--http-code", type=int, default=0, help="HTTP code to match when a query is evaluated to True")
    parser.add_argument(
        "--detection-level", type=int, choices=range(1, 6), default=1, help="diversity level of tests, default 1"
    )
    parser.add_argument(
        "--detection-risk",
        type=int,
        choices=range(1, 4),
        default=1,
        help="aggressiveness level, default 1 (not offensive). 2 adds time based queries, 3 adds OR injections",
    )
    parser.add_argument(
        "--tamper-script",
        choices=ALLOWED_TAMPER_VALUES,
        default="",
        help="use given script for tampering injection data",
    )
    parser.add_argument("--dbms", choices=ALLOWED_DBMS_VALUES, default="", help="test for a specific dbms")
    parser.add_argument("--techniques", default="BEUSTQ", help="SQLi techniques to use, default BEUSTQ (all)")
    parser.add_argument("--payload-prefix", default="", help="string to prepend to each payload, base64 encoded")
    parser.add_argument("--payload-suffix", default="", help="string to append to each payload, base64 encoded")
    parser.add_argument("--extract-user", action="store_true", help="retrieve DBMS current user")
    parser.add_argument("--extract-db", action="store_true", help="retrieve DBMS current database")
    parser.add_argument("--extract-host", action="store_true", help="retrieve DBMS server hostname")
    parser.add_argument("--test-params", default="", help="testable parameters, e.g. id,pass")
    parser.add_argument("--light-crawling", action="store_true", help="performs crawling with depth 2")
    parser.add_argument(
        "--scan-type",
        choices=["deep", "free"],
        default="deep",
        help="whether to perform a scan for a free user, default deep",
    )
    args = parser.parse_args()

    # Initialize the scanner
    # It connects to the Task Agent and waits for requests from there
    scanner = SQLiExploiter(
        base64.b64decode(args.target).decode("utf-8"),
        construct_command(args),
        {
            "user": args.extract_user,
            "db": args.extract_db,
            "host": args.extract_host,
        },
        args.scan_type,
    )

    if not scanner.init():
        if scanner.task_status != TaskStatus.CONN_ERROR:
            logging.error("Could not start SQLi Exploiter")
        sys.exit()

    logging.info("SQLi Exploiter started: %s", sys.argv)

    # Run the tests and wait for output to be collected by Task Agent
    scanner.run()


if __name__ == "__main__":
    main()
